CXX				= g++
SDL_PATH		= C:/libs/SDL-release-3.2.28
SDL_LIB_DIR 	= $(SDL_PATH)/build
SDL_INC			= -I$(SDL_PATH)/include

SDL_TTF_PATH	= C:/libs/SDL_ttf/dist
SDL_TTF_LIB_DIR = $(SDL_TTF_PATH)/lib
SDL_TTF_INC		= -I$(SDL_TTF_PATH)/include
# Static linking requires SDL3 and its Windows dependencies
LDFLAGS 	= -lmingw32 -L$(SDL_LIB_DIR) -L$(SDL_TTF_LIB_DIR) \
          -lSDL3_ttf \
          -lSDL3 -lcurl -lsetupapi -lwinmm -lgdi32 -limm32 -lole32 \
          -loleaut32 -lshell32 -lversion -luuid -luser32 -lrpcrt4 -lshlwapi
CXXFLAGS	= -O3 -Isrc $(SDL_INC) $(SDL_TTF_INC) -static -static-libgcc -static-libstdc++

BIN_DIR		= bin
TARGET		= $(BIN_DIR)/soljumper.exe
SRC_DIR		= src
OBJ_DIR		= obj

# Instead of one wildcard, we find all directories inside src
SUBDIRS     = $(wildcard $(SRC_DIR)/*/)
# We get files from src/ AND all subfolders
SOURCES     = $(wildcard $(SRC_DIR)/*.cpp) $(foreach dir,$(SUBDIRS),$(wildcard $(dir)*.cpp))
# --------------------------------
OBJECTS     = $(patsubst $(SRC_DIR)/%.cpp, $(OBJ_DIR)/%.o, $(subst \,/,$(SOURCES)))

all: $(TARGET)

# Ensure the bin directory exists before linking
$(BIN_DIR):
	@if not exist $(BIN_DIR) mkdir $(BIN_DIR)

$(TARGET): $(OBJECTS) | $(BIN_DIR)
	$(CXX) $(OBJECTS) -o $(TARGET) $(LDFLAGS)

# Rule to compile AND create subdirectories in obj/ automatically
$(OBJ_DIR)/%.o: $(SRC_DIR)/%.cpp
	@if not exist "$(dir $@)" mkdir "$(dir $@)"
	$(CXX) $(CXXFLAGS) -c $< -o $@

# Compile .cpp files into the obj/ folder
$(OBJ_DIR)/%.o: $(SRC_DIR)/%.cpp | $(OBJ_DIR)
	$(CXX) $(CXXFLAGS) -c $< -o $@

clean:
	@if exist $(TARGET).exe del /q $(TARGET).exe
	@if exist $(OBJ_DIR) rmdir /s /q $(OBJ_DIR)

run: all
	./$(TARGET)



	
/*
void PhysSystem::step(SolWorld &world, double dt, double time)
{
    auto &bodies = world.bodies;
    auto &positions = world.positions;
    auto &velocities = world.velocities;

    // 1. Movement pass — only dynamic bodies
    for (int i = 0; i < bodies.size(); ++i)
    {
        int entityId = bodies.getEntityAt(i);
        Comp::Body *body = bodies.get(entityId);
        if (body->type == BodyType::STATIC)
            continue;

        Comp::Velocity *vel = velocities.get(entityId);
        Comp::Position *pos = positions.get(entityId);
        if (!pos || !vel)
            continue;

        const float friction = (body->touching & BodyTouching::TOUCHING_DOWN)
                                   ? body->groundFriction
                                   : body->airFriction;
        vel->vx = MoveUtils::friction(dt, vel->vx, friction);
        body->touching = 0;
        vel->vy += 9.81f * dt;
        pos->x += vel->vx;
        pos->y += vel->vy;
    }

    // 2. Collision pass — all pairs
    for (int i = 0; i < bodies.size(); ++i)
    {
        int idA = bodies.getEntityAt(i);
        Comp::Body *bodyA = bodies.get(idA);
        Comp::Position *posA = positions.get(idA);
        if (!posA || !bodyA)
            continue;

        for (int j = i + 1; j < bodies.size(); ++j)
        {
            int idB = bodies.getEntityAt(j);
            Comp::Body *bodyB = bodies.get(idB);
            Comp::Position *posB = positions.get(idB);
            if (!posB || !bodyB)
                continue;

            // Skip if both static
            if (bodyA->type == BodyType::STATIC && bodyB->type == BodyType::STATIC)
                continue;

            float dx = posB->x - posA->x;
            float dy = posB->y - posA->y;
            float range = bodyA->width + bodyB->width;
            if ((dx * dx + dy * dy) > (range * range))
                continue;

            if (!AABB(posA->x, posA->x + bodyA->width, posA->y, posA->y + bodyA->height,
                      posB->x, posB->x + bodyB->width, posB->y, posB->y + bodyB->height))
                continue;

            Collision colX = getCollision(posA->x, bodyA->width, posB->x, bodyB->width);
            Collision colY = getCollision(posA->y, bodyA->height, posB->y, bodyB->height);

            bool resolveX = colX.overlap < colY.overlap;
            float overlap = resolveX ? colX.overlap : colY.overlap;
            float normal = resolveX ? colX.normal : colY.normal;

            // Resolve positions
            if (bodyA->type == BodyType::STATIC)
            {
                // Only push B
                if (resolveX)
                    posB->x -= overlap * normal;
                else
                    posB->y -= overlap * normal;
            }
            else if (bodyB->type == BodyType::STATIC)
            {
                // Only push A
                if (resolveX)
                    posA->x += overlap * normal;
                else
                    posA->y += overlap * normal;
            }
            else
            {
                // Both dynamic — split by mass
                float totalMass = bodyA->mass + bodyB->mass;
                float ratioA = bodyB->mass / totalMass;
                float ratioB = bodyA->mass / totalMass;
                if (resolveX)
                {
                    posA->x += overlap * normal * ratioA;
                    posB->x -= overlap * normal * ratioB;
                }
                else
                {
                    posA->y += overlap * normal * ratioA;
                    posB->y -= overlap * normal * ratioB;
                }
            }

            // Resolve velocities
            Comp::Velocity *velA = velocities.get(idA);
            Comp::Velocity *velB = velocities.get(idB);

            if (resolveX)
            {
                if (bodyA->type == BodyType::DYNAMIC)
                    bodyA->touching |= (normal < 0) ? TOUCHING_RIGHT : TOUCHING_LEFT;
                if (bodyB->type == BodyType::DYNAMIC)
                    bodyB->touching |= (normal < 0) ? TOUCHING_LEFT : TOUCHING_RIGHT;

                if (bodyA->type == BodyType::STATIC && velB)
                    velB->vx = 0;
                else if (bodyB->type == BodyType::STATIC && velA)
                    velA->vx = 0;
                else if (velA && velB && relativeVel(velA->vx, velB->vx, posA->x, posB->x))
                {
                    float totalMass = bodyA->mass + bodyB->mass;
                    float combined = (velA->vx * bodyA->mass + velB->vx * bodyB->mass) / totalMass;
                    velA->vx = combined;
                    velB->vx = combined;
                }
            }
            else
            {
                if (bodyA->type == BodyType::DYNAMIC)
                    bodyA->touching |= (normal < 0) ? TOUCHING_DOWN : TOUCHING_UP;
                if (bodyB->type == BodyType::DYNAMIC)
                    bodyB->touching |= (normal < 0) ? TOUCHING_UP : TOUCHING_DOWN;

                if (bodyA->type == BodyType::STATIC && velB)
                    velB->vy = 0;
                else if (bodyB->type == BodyType::STATIC && velA)
                    velA->vy = 0;
                else if (velA && velB && relativeVel(velA->vy, velB->vy, posA->y, posB->y))
                {
                    float totalMass = bodyA->mass + bodyB->mass;
                    float combined = (velA->vy * bodyA->mass + velB->vy * bodyB->mass) / totalMass;
                    velA->vy = combined;
                    velB->vy = combined;
                }
            }
        }
    }
}
*/